# Function to generate constraint and/or external forces

# include("RigidBody.jl")
# include("OrientationConversion.jl")
# include("Joint.jl")

using LinearAlgebra
using ForwardDiff
using Revise

function ForceCon(j::Joint,extF1,extF2,GravityInInertial)
    if(j.RB1.m == 0.0)
        # Joint to world. Body is connected to the Inertial frame.
        if j.type == "Revolute"
            Fc = ForceConRevIn(j,extF2,GravityInInertial)
        elseif j.type == "Spherical"
            Fc = ForceConSphIn(j,extF2,GravityInInertial)
        elseif j.type == "Weld"
            Fc = ForceConWeldAllIn(j,extF2,GravityInInertial)
        elseif j.type == "Free"
            Fc = ForceFree(j,extF2,GravityInInertial)
        else
            error("Joint type not prescribed.")
        end
    else
        if j.type == "Revolute"
            Fc = ForceConRev(j,extF1,extF2,GravityInInertial)
        elseif j.type == "Spherical"
            Fc = ForceConSph(j,extF1,extF2,GravityInInertial)
        elseif j.type == "Weld"
            Fc = ForceConWeldAll(j,extF1,extF2,GravityInInertial)
        else
            error("Joint type not prescribed.")
        end
    end
    return Fc
end
# For inertial frame and body
function ForceFree(j::Joint,extF::extForces, GravityInInertial::Vector{Float64})
    # Constraint Force generated due to quaternion constraint
    b2 = j.RB2


    # Revolute Joint has 7 constraints
    A = zeros(1,7); b = [0.0];
    A[1,:] = QuatNormConstraint(j)[1][2,8:14]; b[1] = QuatNormConstraint(j)[2][2]

    # A[1:3,:] = TranslationConstraint(j)[1]; b[1:3] = TranslationConstraint(j)[2]
    # A[5:6,:] = RevJointConstraint(j)[1]; b[5:6] = RevJointConstraint(j)[2]
    # A_in = A[:,8:14]
    # A = zeros(7,14)
    # IMat3 = Matrix{Float64}(I,3,3)
    # t1 = TranslationConstraint(b1.x,rj1)
    # t2 = TranslationConstraint(b2.x,rj2)
    # A[1:3,:] = [-IMat3 t1[1] IMat3 t2[1]]
    # A[4,:] = [zeros(1,11) 1/j.axis[1] -1/j.axis[2] 0]
    # A[5,:] = [zeros(1,11) 1/j.axis[1] 0 -1/j.axis[3]]
    # A[6,:] = [zeros(1,3) transpose(β1) zeros(1,7)]
    # A[7,:] = [zeros(1,10) transpose(β2)]
    #
    # b = zeros(7)
    # b[1:3] = t1[2] + t2[2]
    # b[4:5] = zeros(2)
    # b[6] = -transpose(β1dot)*β1dot
    # b[7] = -transpose(β2dot)*β2dot

    M = genMatM(b2)

    F = genExtF(b2,extF,GravityInInertial)
    Fconstr = ConstraintForceTorque(M,F,A,b)
    return Fconstr
end
function ForceConRevIn(j::Joint, extF2::extForces, GravityInInertial::Vector{Float64})
    # Constraint Force generated by revolute joint
    b2 = j.RB2

    # Revolute Joint has 7 constraints
    A = zeros(6,14); b = zeros(6);
    A[1:3,:] = TranslationConstraint(j)[1]; b[1:3] = TranslationConstraint(j)[2]
    A[4,:] = QuatNormConstraint(j)[1][2,:]; b[4] = QuatNormConstraint(j)[2][2]
    A[5:6,:] = RevJointConstraint(j)[1]; b[5:6] = RevJointConstraint(j)[2]

    A_in = A[:,8:14]
    # A = zeros(7,14)
    # IMat3 = Matrix{Float64}(I,3,3)
    # t1 = TranslationConstraint(b1.x,rj1)
    # t2 = TranslationConstraint(b2.x,rj2)
    # A[1:3,:] = [-IMat3 t1[1] IMat3 t2[1]]
    # A[4,:] = [zeros(1,11) 1/j.axis[1] -1/j.axis[2] 0]
    # A[5,:] = [zeros(1,11) 1/j.axis[1] 0 -1/j.axis[3]]
    # A[6,:] = [zeros(1,3) transpose(β1) zeros(1,7)]
    # A[7,:] = [zeros(1,10) transpose(β2)]
    #
    # b = zeros(7)
    # b[1:3] = t1[2] + t2[2]
    # b[4:5] = zeros(2)
    # b[6] = -transpose(β1dot)*β1dot
    # b[7] = -transpose(β2dot)*β2dot

    M = genMatM(b2)

    F = genExtF(b2,extF2,GravityInInertial)

    Fconstr = ConstraintForceTorque(M,F,A_in,b)
    return Fconstr
end

function ForceConWeldAllIn(j::Joint, extF2::extForces, GravityInInertial::Vector{Float64})
    # Constraint Force generated by weld joint
    b2 = j.RB2

    # Weld Joint has 8/9 constraints
    A = zeros(9,14); b = zeros(9);
    A[1:3,:] = TranslationConstraint(j)[1]; b[1:3] = TranslationConstraint(j)[2]
    A[4:5,:] = QuatNormConstraint(j)[1]; b[4:5] = QuatNormConstraint(j)[2]
    A[6:9,:] = WeldJointAllConstraint(j)[1]; b[6:9] = WeldJointAllConstraint(j)[2]
    A_in = A[:,8:14]

    M = genMatM(b2)

    F = genExtF(b2,extF2,GravityInInertial)

    Fconstr = ConstraintForceTorque(M,F,A_in,b)
    return Fconstr
end

function ForceConSphIn(j::Joint, extF2::extForces, GravityInInertial::Vector{Float64})
    # Constraint Force generated by spherical joint
    b2 = j.RB2

    # Spherical Joint has 5 constraints
    A = zeros(4,14); b = zeros(4)
    A[1:3,:] = TranslationConstraint(j)[1]; b[1:3] = TranslationConstraint(j)[2]
    A[4,:] = QuatNormConstraint(j)[1][2,:]; b[4] = QuatNormConstraint(j)[2][2]
    A_in = A[:,8:14]

    M = genMatM(b2)

    F = genExtF(b2,extF2,GravityInInertial)

    Fconstr = ConstraintForceTorque(M,F,A_in,b)
    return Fconstr
end

# For 2 rigid bodies
function ForceConRev(j::Joint, extF1::extForces, extF2::extForces, GravityInInertial::Vector{Float64})
    # Constraint Force generated by revolute joint
    b1 = j.RB1
    b2 = j.RB2

    # Revolute Joint has 7 constraints
    A = zeros(7,14); b = zeros(7);
    A[1:3,:] = TranslationConstraint(j)[1]; b[1:3] = TranslationConstraint(j)[2]
    A[4:5,:] = QuatNormConstraint(j)[1]; b[4:5] = QuatNormConstraint(j)[2]
    A[6:7,:] = RevJointConstraint(j)[1]; b[6:7] = RevJointConstraint(j)[2]

    # A = zeros(7,14)
    # IMat3 = Matrix{Float64}(I,3,3)
    # t1 = TranslationConstraint(b1.x,rj1)
    # t2 = TranslationConstraint(b2.x,rj2)
    # A[1:3,:] = [-IMat3 t1[1] IMat3 t2[1]]
    # A[4,:] = [zeros(1,11) 1/j.axis[1] -1/j.axis[2] 0]
    # A[5,:] = [zeros(1,11) 1/j.axis[1] 0 -1/j.axis[3]]
    # A[6,:] = [zeros(1,3) transpose(β1) zeros(1,7)]
    # A[7,:] = [zeros(1,10) transpose(β2)]
    #
    # b = zeros(7)
    # b[1:3] = t1[2] + t2[2]
    # b[4:5] = zeros(2)
    # b[6] = -transpose(β1dot)*β1dot
    # b[7] = -transpose(β2dot)*β2dot

    M1 = genMatM(b1)
    M2 = genMatM(b2)
    M = [M1 zeros(size(M1))
         zeros(size(M1)) M2]

    F = [genExtF(b1,extF1,GravityInInertial); genExtF(b2,extF2,GravityInInertial)]

    Fconstr = ConstraintForceTorque(M,F,A,b)
    return Fconstr
end

function ForceConWeldAll(j::Joint, extF1::extForces, extF2::extForces, GravityInInertial::Vector{Float64})
    # Constraint Force generated by weld joint
    b1 = j.RB1
    b2 = j.RB2

    # Weld Joint has 8/9 constraints
    A = zeros(9,14); b = zeros(9);
    A[1:3,:] = TranslationConstraint(j)[1]; b[1:3] = TranslationConstraint(j)[2]
    A[4:5,:] = QuatNormConstraint(j)[1]; b[4:5] = QuatNormConstraint(j)[2]
    A[6:9,:] = WeldJointAllConstraint(j)[1]; b[6:9] = WeldJointAllConstraint(j)[2]

    M1 = genMatM(b1)
    M2 = genMatM(b2)
    M = [M1 zeros(size(M1))
         zeros(size(M1)) M2]

    F = [genExtF(b1,extF1,GravityInInertial); genExtF(b2,extF2,GravityInInertial)]

    Fconstr = ConstraintForceTorque(M,F,A,b)
    return Fconstr
end

function ForceConSph(j::Joint, extF1::extForces, extF2::extForces, GravityInInertial::Vector{Float64})
    # Constraint Force generated by spherical joint
    b1 = j.RB1
    b2 = j.RB2

    # Spherical Joint has 5 constraints
    A = zeros(5,14); b = zeros(5)
    A[1:3,:] = TranslationConstraint(j)[1]; b[1:3] = TranslationConstraint(j)[2]
    A[4:5,:] = QuatNormConstraint(j)[1]; b[4:5] = QuatNormConstraint(j)[2]

    M1 = genMatM(b1)
    M2 = genMatM(b2)
    M = [M1 zeros(size(M1))
         zeros(size(M1)) M2]

    F = [genExtF(b1,extF1,GravityInInertial); genExtF(b2,extF2,GravityInInertial)]

    Fconstr = ConstraintForceTorque(M,F,A,b)
    return Fconstr
end
# forward diff
# Translation constraint
function TranslationConstraint(j::Joint)#(x::Vector{Float64},pos::Vector{Float64})
    # r(y) = transpose(quat2dcm(y))*pos
    # rJac(z) = ForwardDiff.jacobian(r,z)
    # rdot(y::AbstractVector) = ForwardDiff.jacobian(r,y)*βdot

    b1 = j.RB1
    b2 = j.RB2
    rj1 = j.pos1
    rj2 = j.pos2
    β1 = b1.x[4:7]
    β2 = b2.x[4:7]
    β1dot = b1.x[11:14]
    β2dot = b2.x[11:14]

    A = zeros(3,14)
    A[:,1:3] = Matrix{Float64}(I,3,3)
    A[:,8:10] = -Matrix{Float64}(I,3,3)
    A[:,4:7] = TranslationConstraintSupplement(b1.x,rj1)[1]
    A[:,11:14] = -TranslationConstraintSupplement(b2.x,rj2)[1]

    b = zeros(3)

    b[1:3] = -TranslationConstraintSupplement(b1.x,rj1)[2] + TranslationConstraintSupplement(b2.x,rj2)[2]

    return (A,b)
    # rddotRHS = ForwardDiff.jacobian(rdot,β)*βdot
    # rddotLHS = -rJac(β)
    # return (rddotLHS,rddotRHS)
end

function TranslationConstraintSupplement(x::Vector{T},pos::Vector{T}) where T <: Real
    β = x[4:7]
    βdot = x[11:14]
    r(y::Vector{T}) where T<:Real = transpose(quat2dcm(y))*pos
    rJac = z->ForwardDiff.jacobian(r,z)
    rdot(y) = ForwardDiff.jacobian(r,y)*βdot
    rddotRHS = ForwardDiff.jacobian(rdot,β)*βdot
    rddotLHS = rJac(β)
    return (rddotLHS,rddotRHS)
end

function QuatNormConstraint(j::Joint)
    A = zeros(2,14)
    b = zeros(2)

    b1 = j.RB1
    b2 = j.RB2
    rj1 = j.pos1
    rj2 = -j.pos2

    β1 = b1.x[4:7]
    β2 = b2.x[4:7]
    β1dot = b1.x[11:14]
    β2dot = b2.x[11:14]

    A[1,4:7] = β1
    A[2,11:14] = β2
    b[1] = -transpose(β1dot)*β1dot
    b[2] = -transpose(β2dot)*β2dot
    return (A,b)
end

# function RevJointConstraint(j::Joint)
#     axis = j.axis
#
#
#     A = zeros(2,14)
#     b = zeros(2)
#     A[1,12:13] = [1/axis[1] -1/axis[2]]
#     A[2,12] = 1/axis[1];
#     A[2,14] = -1/axis[3]
#
#     return (A,b)
# end

function RevJointConstraint(j::Joint)
    function f(y::Vector{T}) where T <: Real
        # Computes the Hamilton product of β1^-1 and β2
        y1 = [y[1];-y[2:4]]
        y2 = y[5:8]
        x = [y1[1]*y2[1] - transpose(y1[2:4])*y2[2:4];
             y1[1]*y2[2:4] + y2[1]*y1[2:4] + cross(y1[2:4],y2[2:4])]
        return x
    end
    fJac = z->ForwardDiff.jacobian(f,z)
    fdotJac = z->ForwardDiff.jacobian(fJac,z)

    axis = j.axis
    a1, a2, a3 = axis
    b1 = j.RB1
    b2 = j.RB2
    β1 = b1.x[4:7]
    β2 = b2.x[4:7]
    β1dot = b1.x[11:14]
    β2dot = b2.x[11:14]
    β = [β1;β2]

    # β1 = x1[4:7]
    # β2 = x2[4:7]
    # β1dot = x1[11:14]
    # β2dot = x2[11:14]

    y1 = f(β)
    y2 = fJac(β)
    y3 = fdotJac(β)
    x1 = y3[1:16,1:4]*β1dot; x1 = reshape(x1,(4,4))
    x2 = y3[1:16,5:8]*β2dot; x2 = reshape(x2,(4,4))
    x3 = y3[17:end,1:4]*β1dot; x3 = reshape(x3,(4,4))
    x4 = y3[17:end,5:8]*β2dot; x4 = reshape(x4,(4,4))
    qddotA = [zeros(4,3) -fJac(β)[:,1:4] zeros(4,3) -fJac(β)[:,5:8]]
    qddotb = (x1+x2)*β1dot + (x3+x4)*β2dot

    nnzAxis = findall(!iszero,axis)
    zAxis = findall(iszero,axis)
    l = length(nnzAxis) # Counts the number of nonzero elements in axis
    A = zeros(2,14); b = zeros(2)
    if l==3
        A[1,:] = qddotA[2,:]/a1 - qddotA[3,:]/a2
        b[1] = qddotb[2]/a1 - qddotb[3]/a2
        A[2,:] = qddotA[2,:]/a1 - qddotA[4,:]/a3
        b[2,:] = qddotb[2]/a1 - qddotb[4]/a3
    elseif l==2
        A[1,:] = qddotA[nnzAxis[1]+1,:]/axis[nnzAxis[1]] - qddotA[nnzAxis[2]+1,:]/axis[nnzAxis[2]]
        b[1] = qddotb[nnzAxis[1]+1]/axis[nnzAxis[1]] - qddotb[nnzAxis[2]+1]/axis[nnzAxis[2]]
        A[2,:] = qddotA[zAxis[1]+1,:]
    elseif l==1
        A[1,:] = qddotA[zAxis[1]+1,:]
        A[2,:] = qddotA[zAxis[2]+1,:]
    else
        error("Joint axis provided not possible.")
    end
    return (A,b)
end
function WeldJointAllConstraint(j::Joint)
    b1 = j.RB1
    b2 = j.RB2

    A = zeros(4,14)
    b = zeros(4)
    y = WeldJointAllConstraintSupplement(b1.x,b2.x)
    A[:,4:7] = y[1][1]
    A[:,11:14] = y[1][2]
    b = y[2]
    return (A,b)
end

function WeldJointAllConstraintSupplement(x1::Vector{T},x2::Vector{T}) where T <: Real
    function f(y::Vector{T}) where T <: Real
        # Computes the Hamilton product of β1^-1 and β2
        y1 = [y[1];-y[2:4]]
        y2 = y[5:8]
        x = [y1[1]*y2[1] - transpose(y1[2:4])*y2[2:4];
             y1[1]*y2[2:4] + y2[1]*y1[2:4] + cross(y1[2:4],y2[2:4])]
        return x
    end
    fJac = z->ForwardDiff.jacobian(f,z)
    fdotJac = z->ForwardDiff.jacobian(fJac,z)

    β1 = x1[4:7]
    β2 = x2[4:7]
    β1dot = x1[11:14]
    β2dot = x2[11:14]
    β = [β1;β2]

    y1 = f(β)
    y2 = fJac(β)
    y3 = fdotJac(β)
    y3r = reshape(y3,(4,8,8))
    x1 = y3[1:16,1:4]*β1dot; x1 = reshape(x1,(4,4))
    x2 = y3[1:16,5:8]*β2dot; x2 = reshape(x2,(4,4))
    x3 = y3[17:end,1:4]*β1dot; x3 = reshape(x3,(4,4))
    x4 = y3[17:end,5:8]*β2dot; x4 = reshape(x4,(4,4))
    # β = rand(8); β1dot = rand(4); β2dot = rand(4);
    LHS = (-fJac(β)[:,1:4],-fJac(β)[:,5:8])
    RHS = (x1+x2)*β1dot + (x3+x4)*β2dot
    return (LHS,RHS)

end
function ConstraintForceTorque(M,F,A,b)
    # @show A
    # @show b
    # @show A*inv(M)*F
    Fc = sqrt(M)*pinv(A*M^(-1/2))*(b-A*inv(M)*F)
    # @show Fc
    return Fc
    # Fc is in the inertial frame
end

function genMatM(b::RigidBody)
    # Function to generate mass matrix for each rigid body
    β = b.x[4:7]
    E = genE(β)
    J = b.J
    M = [b.m*Matrix{Float64}(I,3,3)          zeros(3,4)
                         zeros(4,3) 4*transpose(E)*J*E]
end

function genExtF(b::RigidBody,extF::extForces,GravityInInertial::Vector{Float64})
    # Function to generate augmented external Force vector for unconstrained system
    β = b.x[4:7]
    βdot = b.x[11:14]
    b.dcm = quat2dcm(β)
    b.ω = angVel(β,βdot)
    E = genE(β)
    Edot = -genE(βdot)
    TotalMoment = zeros(3)
    # J0 = rand(1)# random positive number
    for i in 1:size(extF.Forces)[1]
        TotalMoment = TotalMoment + cross(extF.Positions[i,:],extF.Forces[i,:])
    end
    TotalMoment = TotalMoment + sum(extF.Torques,dims=1)[:]
    # TotalMoment = transpose(b.dcm)*TotalMoment
    Γb = [0.0;TotalMoment] # In the body frame
    Γu = 2*E*Γb
    # @show β
    # @show transpose(b.dcm)
    # @show (sum(extF.Forces,dims=1)[:])

    F = [transpose(b.dcm)*(sum(extF.Forces,dims=1)[:]) + b.m*GravityInInertial
         Γu - 8*transpose(Edot)*b.J*E*βdot - 4*b.J[1,1]*(transpose(βdot)*βdot)*β]
    return F
    # F returned is in the inertial frame
end
