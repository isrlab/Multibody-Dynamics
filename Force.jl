# Function to generate constraint and/or external forces

include("RigidBody.jl")
include("OrientationConversion.jl")
include("Joint.jl")

using LinearAlgebra
using ForwardDiff

function ForceConRev(j::RevJoint, extF1::extForces, extF2::extForces, GravityInInertial::Vector{Float64})
    # Constraint Force generated by revolute joint
    b1 = j.RB1
    b2 = j.RB2
    rj1 = j.pos1
    rj2 = -j.pos2

    β1 = b1.x[4:7]
    β2 = b2.x[4:7]
    β1dot = b1.x[11:14]
    β2dot = b2.x[11:14]


    A = zeros(7,14)
    IMat3 = Matrix{Float64}(I,3,3)
    t1 = TranslationConstraint(b1.x,rj1)
    t2 = TranslationConstraint(b2.x,rj2)
    A[1:3,:] = [-IMat3 t1[1] IMat3 t2[1]]
    A[4,:] = [zeros(1,11) 1/j.axis[1] -1/j.axis[2] 0]
    A[5,:] = [zeros(1,11) 1/j.axis[1] 0 -1/j.axis[3]]
    A[6,:] = [zeros(1,3) transpose(β1) zeros(1,7)]
    A[7,:] = [zeros(1,10) transpose(β2)]

    b = zeros(7)
    b[1:3] = t1[2] + t2[2]
    b[4:5] = zeros(2)
    b[6] = -transpose(β1)*β1
    b[7] = -transpose(β2)*β2

    M1 = genMatM(b1)
    M2 = genMatM(b2)
    M = [M1 zeros(size(M1))
         zeros(size(M1)) M2]

    F = [genExtF(b1,extF1,GravityInInertial); genExtF(b2,extF2,GravityInInertial)]

    Fconstr = ConstraintForceTorque(M,F,A,b)
    return Fconstr
end

# forward diff
# Translation constraint
function TranslationConstraint(x::Vector{Float64},pos::Vector{Float64})
    r(y::AbstractVector) = transpose(quat2dcm(y))*pos
    β = x[4:7]
    βdot = x[11:14]
    rJac = z->ForwardDiff.jacobian(r,z)
    rdot(y::AbstractVector) = ForwardDiff.jacobian(r,y)*βdot
    rddotRHS = ForwardDiff.jacobian(rdot,β)*βdot
    rddotLHS = -rJac(β)
    return (rddotLHS,rddotRHS)
end

function ConstraintForceTorque(M,F,A,b)
    @show M
    @show M^-0.5
    @show A*M^-0.5
    Fc = sqrt(M)*pinv(A*M^(-1/2))*(b-A*inv(M)*F)
end
