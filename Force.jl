# Function to generate constraint and/or external forces

include("RigidBody.jl")
include("OrientationConversion.jl")
include("Joint.jl")

using LinearAlgebra
using ForwardDiff
using Revise

function ForceConRev(j::RevJoint, extF1::extForces, extF2::extForces, GravityInInertial::Vector{Float64})
    # Constraint Force generated by revolute joint
    b1 = j.RB1
    b2 = j.RB2
    rj1 = j.pos1
    rj2 = -j.pos2

    β1 = b1.x[4:7]
    β2 = b2.x[4:7]
    β1dot = b1.x[11:14]
    β2dot = b2.x[11:14]

    # Revolute Joint has 7 constraints
    A = zeros(7,14); b = zeros(14);
    A[1:3,:] = TranslationConstraint(j)[1]; b[1:3] = TranslationConstraint(j)[2]
    A[4:5,:] = QuatNormConstraint(j)[1]; b[4:5] = QuatNormConstraint(j)[2]
    A[6:7,:] = RevJointConstraint(j)[1]; b[6:7] = RevJointConstraint(j)[2]
    
    # A = zeros(7,14)
    # IMat3 = Matrix{Float64}(I,3,3)
    # t1 = TranslationConstraint(b1.x,rj1)
    # t2 = TranslationConstraint(b2.x,rj2)
    # A[1:3,:] = [-IMat3 t1[1] IMat3 t2[1]]
    # A[4,:] = [zeros(1,11) 1/j.axis[1] -1/j.axis[2] 0]
    # A[5,:] = [zeros(1,11) 1/j.axis[1] 0 -1/j.axis[3]]
    # A[6,:] = [zeros(1,3) transpose(β1) zeros(1,7)]
    # A[7,:] = [zeros(1,10) transpose(β2)]
    #
    # b = zeros(7)
    # b[1:3] = t1[2] + t2[2]
    # b[4:5] = zeros(2)
    # b[6] = -transpose(β1dot)*β1dot
    # b[7] = -transpose(β2dot)*β2dot

    M1 = genMatM(b1)
    M2 = genMatM(b2)
    M = [M1 zeros(size(M1))
         zeros(size(M1)) M2]

    F = [genExtF(b1,extF1,GravityInInertial); genExtF(b2,extF2,GravityInInertial)]

    Fconstr = ConstraintForceTorque(M,F,A,b)
    return Fconstr
end

# forward diff
# Translation constraint
function TranslationConstraint(j::Joint)#(x::Vector{Float64},pos::Vector{Float64})
    # r(y) = transpose(quat2dcm(y))*pos
    # rJac(z) = ForwardDiff.jacobian(r,z)
    # rdot(y::AbstractVector) = ForwardDiff.jacobian(r,y)*βdot

    b1 = j.RB1
    b2 = j.RB2
    rj1 = j.pos1
    rj2 = -j.pos2
    β1 = b1.x[4:7]
    β2 = b2.x[4:7]
    β1dot = b1.x[11:14]
    β2dot = b2.x[11:14]

    A = zeros(3,14)
    A[:,1:3] = -Matrix{Float64}(I,3,3)
    A[:,8:10] = Matrix{Float64}(I,3,3)
    A[:,4:7] = TranslationConstraintSupplement(b1.x,rj1)[1]
    A[:,11:14] = TranslationConstraintSupplement(b2.x,rj2)[1]

    b = zeros(3)
    b[1:3] = TranslationConstraintSupplement(b1.x,rj1)[2] + TranslationConstraintSupplement(b2.x,rj2)

    return (A,b)
    # rddotRHS = ForwardDiff.jacobian(rdot,β)*βdot
    # rddotLHS = -rJac(β)
    # return (rddotLHS,rddotRHS)
end

function TranslationConstraintSupplement(x,pos)
    β = x[4:7]
    βdot = x[11:14]
    r(y::Vector{T}) where T<:Real = transpose(quat2dcm(y))*pos
    rJac = z->ForwardDiff.jacobian(r,z)
    rdot(y) = ForwardDiff.jacobian(r,y)*βdot
    rddotRHS = ForwardDiff.jacobian(rdot,β)*βdot
    rddotLHS = -rJac(β)
    return (rddotLHS,rddotRHS)
end

function QuatNormConstraint(j::Joint)
    A = zeros(2,14)
    b = zeros(2)

    b1 = j.RB1
    b2 = j.RB2
    rj1 = j.pos1
    rj2 = -j.pos2

    β1 = b1.x[4:7]
    β2 = b2.x[4:7]
    β1dot = b1.x[11:14]
    β2dot = b2.x[11:14]

    A[1,4:7] = β1
    A[2,11:14] = β2
    b[1] = -transpose(β1dot)*β1dot
    b[2] = -transpose(β2dot)*β2dot
    return (A,b)
end

function RevJointConstraint(j::Joint)
    axis = j.axis
    A = zeros(2,14)
    b = zeros(2,14)
    A[1,12:13] = [1/axis[1];-1/axis[2]]
    A[2,12] = 1/axis[1]; A[2,14] = -1/axis[3]

    return (A,b)
end




function ConstraintForceTorque(M,F,A,b)
    @show M
    @show M^-0.5
    @show A*M^-0.5
    Fc = sqrt(M)*pinv(A*M^(-1/2))*(b-A*inv(M)*F)
end
